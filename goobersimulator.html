<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Goober Simulator</title>
    <meta property="og:url" content="https://jakedravioli.neocities.org/goobersimulator">
    <meta property="og:type" content="website">
    <meta property="og:title" content="JakeDRavioli's Goober Simulator">
    <meta property="og:description" content="Welcome to the goofiest simulator that contains like, all of my characters doing the silliest stuff.">
    <meta property="og:image" content="https://jakedravioli.neocities.org/Images/jdr.png">
    <meta name="theme-color" content="#3d2996">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Permanent+Marker&family=Sedgwick+Ave+Display&display=swap" rel="stylesheet">

    <style>
        /* --- General Setup --- */
        :root {
            --primary-color: #ff384f;
            --background-color: #1a1a1a;
            --container-bg-color: #121212;
            --text-color: #f0f0f0;
            --border-color: #444;
        }

        body { 
            background-color: var(--background-color); 
            color: var(--text-color); 
            font-family: 'Arial', sans-serif; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            min-height: 100vh; 
            height: auto; 
            margin: 0; 
            padding: 20px 0; 
            box-sizing: border-box; 
        }
        body::before { 
            content: ''; 
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            background-image: url('https://jakedravioli.neocities.org/rebellioustakeover/Images/rebTakeover/rebBackground-min.png'); 
            background-size: cover; 
            background-position: center; 
            background-attachment: fixed; 
            opacity: 0.1; 
            z-index: -1; 
        }

        /* --- Layout --- */
        .main-container { 
            display: flex; 
            align-items: center; 
            gap: 30px; 
            width: 95vw; 
            max-width: 1700px; 
        }
        #environment { 
            flex: 3; 
            background-color: var(--container-bg-color); 
            border: 4px solid var(--border-color); 
            border-radius: 12px; 
            position: relative; 
            overflow: hidden; 
            box-shadow: 0 0 20px rgba(0,0,0,0.5); 
            perspective: 1000px; 
            aspect-ratio: 16 / 9; 
        }
        #environment.is-shaking {
            animation: screen-shake 0.5s infinite;
        }
        .side-panel { 
            flex: 1; 
            height: calc( ( (95vw - 30px) / 4 ) * 3 * (9 / 16) ); 
            max-height: 720px; 
            display: flex; 
            flex-direction: column; 
            gap: 20px; 
        }
        .info-panel { 
            background-color: rgba(10, 10, 10, 0.7); 
            border: 2px solid var(--border-color); 
            border-radius: 12px; 
            padding: 20px; 
        }
        .info-panel h2 { 
            font-family: 'Sedgwick Ave Display', cursive; 
            color: var(--primary-color); 
            text-align: center; 
            font-size: 2em; 
            margin: 0 0 15px 0; 
            text-shadow: 2px 2px 5px #000; 
        }
        .info-panel p { 
            font-family: 'Permanent Marker', cursive; 
            font-size: 1.1em; 
            line-height: 1.6; 
            color: #ccc; 
            text-align: center; 
        }
        .button-container {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }
        #debug-toggle-btn, #shake-btn, #jam-btn { 
            flex: 1;
            display: block; 
            width: 100%; 
            padding: 10px; 
            font-family: 'Permanent Marker', cursive; 
            font-size: 1.2em; 
            color: #111; 
            background-color: var(--primary-color); 
            border: none; 
            cursor: pointer; 
            clip-path: polygon(0 0, 100% 0, 100% calc(100% - 10px), calc(100% - 10px) 100%, 0 100%); 
            transition: background-color 0.2s ease; 
        }
        #debug-toggle-btn:hover, #shake-btn:hover, #jam-btn:hover { background-color: #ff5c5c; }
        
        #debug-panel { 
            flex-grow: 1; 
            background-color: rgba(0,0,0,0.8); 
            border: 2px solid var(--border-color); 
            border-radius: 12px; 
            padding: 15px; 
            font-family: 'Courier New', monospace; 
            font-size: 0.85em; 
            color: #0f0; 
            overflow-y: auto; 
        }
        #debug-panel.hidden { display: none; }
        #debug-panel pre { margin: 0; white-space: pre-wrap; word-wrap: break-word; }

        /* --- Character Simulation --- */
        .character { 
            position: absolute; 
            width: 75px; 
            height: 105px; 
            background-size: contain; 
            background-repeat: no-repeat; 
            background-position: center bottom; 
            image-rendering: pixelated; 
            user-select: none; 
            transition: transform 0.1s ease-out;
        }
        .blink-sprite, .work-accessory {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center bottom;
            display: none;
            pointer-events: none;
        }
        .character.is-draggable { cursor: grab; }
        .character.is-dragging, .character.is-shaken {
            cursor: grabbing;
            z-index: 1000;
            transition: none;
        }
        .character.is-dragging {
             transform: scale(1.2);
        }

        /* Character Animations & States */
        .character.is-flipping { animation: paper-flip 0.4s ease-in-out; }
        .character.is-moving { animation: waddle-jump 0.6s infinite; }
        .character.is-working { animation: waddle-jump-slow 1.2s infinite; }
        .character.is-angry { animation: character-shake 0.1s infinite; }
        .character.is-sad { transform: translateY(5px) rotate(7deg); }
        .character.is-happy { animation: waddle-jump 0.6s infinite; }

        /* Speech Bubbles & Effects (Using separate div for stability) */
        .character-bubble {
            position: absolute;
            display: none;
            background-color: #fff;
            color: #000;
            padding: 2px 8px;
            border-radius: 10px;
            font-weight: bold;
            z-index: 1001;
            pointer-events: none;
            white-space: nowrap;
            transform: translateX(-50%);
            animation: bubble-bounce 1.5s infinite;
        }
        .character-bubble.is-working-bubble {
            background-color: #ccc;
            animation: bubble-bounce 2s infinite;
        }
        .character-bubble.is-adoring-bubble {
            content: '';
            background-image: url('https://files.catbox.moe/ea9q6o.png');
            background-color: transparent;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            width: 30px;
            height: 30px;
            padding: 0;
            animation: heart-pulse 1s infinite;
        }

        /* --- Visual Novel Scene --- */
        #vn-container { 
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            background-color: rgba(0, 0, 0, 0.7); 
            display: none; 
            justify-content: center; 
            align-items: flex-end; 
            z-index: 100; 
            cursor: pointer; 
        }
        #vn-portraits-container { 
            position: absolute; 
            top: 0; 
            left: 0; 
            bottom: 220px; 
            width: 100%; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            padding: 0 2%; 
            box-sizing: border-box; 
        }
        #vn-portraits-container.participant-count-2 { justify-content: space-between; padding: 0 10%; }
        #vn-portraits-container.participant-count-3 { justify-content: space-around; }
        #vn-portraits-container.participant-count-4 { justify-content: space-around; }
        
        .vn-portrait { 
            width: 300px; 
            height: 420px; 
            background-size: contain; 
            background-position: center bottom; 
            background-repeat: no-repeat; 
            image-rendering: pixelated; 
            user-select: none; 
            filter: brightness(0.5); 
            transition: filter 0.3s ease-in-out; 
            transform-origin: bottom center; 
            position: relative;
        }
        .vn-portrait.is-speaking { filter: brightness(1) drop-shadow(0 0 15px var(--primary-color)); }
        .vn-portrait.is-speaking-animating { animation: waddle-jump 0.6s infinite; }

        #vn-box { 
            width: 90%; 
            max-width: 820px; 
            height: 200px; 
            background-color: rgba(10, 10, 10, 0.9); 
            border: 3px solid var(--primary-color); 
            margin-bottom: 20px; 
            padding: 20px 30px; 
            box-sizing: border-box; 
            position: relative; 
            color: #fff; 
            cursor: default; 
            z-index: 101; 
            clip-path: polygon(0 0, 100% 0, 100% calc(100% - 20px), calc(100% - 20px) 100%, 0 100%);
            margin-top: 30px; 
        }
        #speaker-name { 
            background-color: var(--primary-color); 
            color: #111; 
            padding: 10px 35px; 
            position: absolute; 
            top: -35px; 
            left: 20px; 
            font-family: 'Sedgwick Ave Display', cursive; 
            font-size: 28px; 
            white-space: nowrap; 
            clip-path: polygon(0 0, 100% 0, 100% calc(100% - 10px), calc(100% - 10px) 100%, 0 100%); 
        }
        #dialogue-text { 
            font-family: 'Permanent Marker', cursive; 
            font-size: 1.5em; 
            line-height: 1.6; 
            letter-spacing: 1px; 
            margin-top: 20px; 
        }
        #dialogue-text .cursor { 
            display: inline-block; 
            background-color: var(--text-color); 
            width: 10px; 
            height: 1.2em; 
            animation: blink 1s infinite; 
            margin-left: 2px; 
        }
        #dialogue-advance-icon { 
            position: absolute; 
            bottom: 15px; 
            right: 20px; 
            font-size: 1.5em; 
            color: var(--primary-color); 
            animation: bounce-arrow 1s infinite; 
            display: none; 
        }

        /* --- Keyframe Animations --- */
        @keyframes paper-flip { 0% { transform: scaleX(var(--direction-old, 1)) rotateY(0deg); } 50% { transform: scaleX(var(--direction-old, 1)) rotateY(90deg); } 100% { transform: scaleX(var(--direction-new, 1)) rotateY(0deg); } }
        @keyframes waddle-jump { 0%, 100% { transform: translateY(0) rotate(0); } 25% { transform: translateY(-20px) rotate(-15deg); } 50% { transform: translateY(0) rotate(0); } 75% { transform: translateY(-20px) rotate(15deg); } }
        @keyframes waddle-jump-slow { 0%, 100% { transform: translateY(0) rotate(0); } 25% { transform: translateY(-10px) rotate(-5deg); } 50% { transform: translateY(0) rotate(0); } 75% { transform: translateY(-10px) rotate(5deg); } }
        @keyframes character-shake { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-4px); } 75% { transform: translateX(4px); } }
        @keyframes screen-shake { 0% { transform: translate(1px, 1px) rotate(0deg); } 10% { transform: translate(-1px, -2px) rotate(-1deg); } 20% { transform: translate(-3px, 0px) rotate(1deg); } 30% { transform: translate(3px, 2px) rotate(0deg); } 40% { transform: translate(1px, -1px) rotate(1deg); } 50% { transform: translate(-1px, 2px) rotate(-1deg); } 60% { transform: translate(-3px, 1px) rotate(0deg); } 70% { transform: translate(3px, 1px) rotate(-1deg); } 80% { transform: translate(-1px, -1px) rotate(1deg); } 90% { transform: translate(1px, 2px) rotate(0deg); } 100% { transform: translate(1px, -2px) rotate(-1deg); } }
        @keyframes bubble-bounce { 0%, 100% { transform: translate(-50%, 0); } 50% { transform: translate(-50%, -5px); } }
        @keyframes heart-pulse { 0%, 100% { transform: translate(-50%, 0) scale(1); } 50% { transform: translate(-50%, -5px) scale(1.2); } }
        @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0; } }
        @keyframes bounce-arrow { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-5px); } }
        
        /* --- Responsive Design --- */
        @media (max-width: 1200px) {
            body { height: auto; padding: 20px; }
            .main-container { flex-direction: column; width: 100%; }
            #environment { width: 90vw; }
            .side-panel { width: 90vw; height: auto; max-height: 50vh; }
            .vn-portrait { width: 25vw; height: 35vw; }
        }
    </style>
</head>
<body>

    <div class="main-container">
        <div id="environment"></div>
        <div class="side-panel">
            <div class="info-panel">
                <h2>Goober Simulator</h2>
                <p>A little simulation of little versions of all of my OCs! They can do all kinds of stuff - So see what you can do!</p>
                <div class="button-container">
                    <button id="shake-btn">Shake</button>
                    <button id="jam-btn">Let 'em Jam</button>
                    <button id="debug-toggle-btn">Toggle Debug</button>
                </div>
            </div>
            <div id="debug-panel" class="hidden">
                <pre id="debug-content"></pre>
                <div id="beatDebugSection" style="margin-top:8px; display:none;">
                    <canvas id="fluxCanvas" width="300" height="60"
                        style="background:#111; border:1px solid #333; display:block; margin-bottom:4px; width: 100%;"></canvas>
                    <div id="beatInfo" style="font-family: monospace; font-size: 12px; color:#0f0;"></div>
                </div>
            </div>
        </div>
    </div>

    <div id="vn-container">
        <div id="vn-portraits-container"></div>
        <div id="vn-box">
            <div id="speaker-name">Character</div>
            <p id="dialogue-text"></p>
            <div id="dialogue-advance-icon">V</div>
        </div>
    </div>

    <script>
        // --- DOM Elements --- //
        const environment = document.getElementById('environment');
        const vnContainer = document.getElementById('vn-container');
        const vnPortraitsContainer = document.getElementById('vn-portraits-container');
        const speakerName = document.getElementById('speaker-name');
        const dialogueText = document.getElementById('dialogue-text');
        const advanceIcon = document.getElementById('dialogue-advance-icon');
        const debugToggleBtn = document.getElementById('debug-toggle-btn');
        const shakeBtn = document.getElementById('shake-btn');
        const jamBtn = document.getElementById('jam-btn');
        const debugPanel = document.getElementById('debug-panel');
        const debugContent = document.getElementById('debug-content');
        const beatDebugSection = document.getElementById('beatDebugSection');
        const fluxCanvas = document.getElementById("fluxCanvas");
        const fluxCtx = fluxCanvas.getContext("2d");
        const beatInfoDiv = document.getElementById("beatInfo");

        // --- Character & Conversation Data --- //
        const characterData = [
            { name: "Deren",  imgUrl: "https://files.catbox.moe/z9nvsw.png", blinkSprite: "https://files.catbox.moe/lymz24.png", partner: "Phenn",  specialIdle: "working", workEmoji: "âš™ï¸", dragLines: ["Uhh... You gonn' put me down?", "Manual override detected.", "Please don't touch the C.O.R.E."], shakeLines: ["Structural integrity failing!", "My C.O.R.E. is getting scrambled!", "This is not a valid simulation parameter!"] },
            { name: "Phenn",  imgUrl: "https://files.catbox.moe/iobp6j.png", blinkSprite: "https://files.catbox.moe/tsgvua.png", partner: "Deren",  specialIdle: "working", workEmoji: "ðŸŽ¨", dragLines: ["H-hey!", "Eep!", "...Please put me down."], shakeLines: ["Eek!", "W-whoa!", "I'm getting dizzy..."] },
            { name: "Lyra",   imgUrl: "https://files.catbox.moe/zwzhok.png", blinkSprite: "https://files.catbox.moe/dkki7l.png", workSpriteUrl: "https://files.catbox.moe/87qofz.png", partner: "Jayce",  specialIdle: "working", workEmoji: "ðŸ‘¾", dragLines: ["Unhand me, peasant!", "Do you have a license for that?", "This is so not poggers."], shakeLines: ["Seizure warning, lol.", "Is this a feature or a bug?", "Poggers, a mosh pit!"] },
            { name: "Jayce",  imgUrl: "https://files.catbox.moe/iqcf05.png", blinkSprite: "https://files.catbox.moe/lymz24.png", partner: "Lyra",   specialIdle: "working", workEmoji: "ðŸ“–", dragLines: ["Okay, this is happening.", "Personal space, please.", "My glasses are slipping."], shakeLines: ["Okay, everything's vibrating.", "My glasses are gonna fall off.", "This is... a lot."] },
            { name: "Goober", imgUrl: "https://files.catbox.moe/nxlfkq.png", blinkSprite: "https://files.catbox.moe/dh5gaj.png", partner: null,     specialIdle: "working", workEmoji: "ðŸª™", dragLines: ["Whoa, we're flying!", "Is this a bonus level?!", "Wheee! This is fun, omnipotent cursor!"], shakeLines: ["EARTHQUAKE LEVEL!", "SHAKE IT! SHAKE IT FOR COINS!", "Wiggle wiggle wiggle!"] },
            { name: "Envo",   imgUrl: "https://files.catbox.moe/fewz30.png", blinkSprite: "https://files.catbox.moe/uwgc5n.png", partner: null,     specialIdle: "working", workEmoji: "ðŸš¬", dragLines: ["Oh, for... just drop me already.", "This is somehow worse.", "Can you not?"], shakeLines: ["Oh, great. Now the whole world is having a panic attack.", "Just... kill me.", "Can you fucking not?"] },
            { name: "Hoobert",imgUrl: "https://files.catbox.moe/rvznqa.png", blinkSprite: "https://files.catbox.moe/ut6v1h.png", partner: null,     specialIdle: "working", workEmoji: "ðŸ“‹", dragLines: ["Asset relocation is unauthorized!", "User. Stop.", "Cease your actions, user."], shakeLines: ["System instability detected!", "User is violating operational parameters!", "MALFUNCTION! MALFUNCTION!"] },
            { name: "Ral",    imgUrl: "https://files.catbox.moe/vb86kr.png", blinkSprite: "https://files.catbox.moe/a7djzt.png", partner: "Cel",    specialIdle: "working", workEmoji: "ðŸ’£", dragLines: ["We're going on an adventure!", "Whee!", "Put me down or I'll bite your ankles!"], shakeLines: ["YEAH! LET'S GOOOO!", "MORE! SHAKE IT MORE!", "This is better than coffee!"] },
            { name: "Cel",    imgUrl: "https://files.catbox.moe/njwkaz.png", blinkSprite: "https://files.catbox.moe/hm10fo.png", partner: "Ral",    specialIdle: "working", workEmoji: "â˜•", dragLines: ["Okay, what's the plan here?", "This is... unexpected.", "Careful."], shakeLines: ["Okay, deep breaths.", "I'm going to be sick.", "Ral, are you doing this?"] },
            { name: "Mae",    imgUrl: "https://files.catbox.moe/j0gnwx.png", blinkSprite: "https://files.catbox.moe/tjrvwc.png", partner: "Luca",   specialIdle: "working", workEmoji: "ðŸ”§", dragLines: ["Oh! Um, hello?", "This is a little high up...", "Please be gentle!"], shakeLines: ["Whoa! Is everything okay?!", "Hold on to something!", "This is... turbulent."] },
            { name: "Luca",   imgUrl: "https://files.catbox.moe/l1qp3a.png", blinkSprite: "https://files.catbox.moe/g31qkq.png", partner: "Mae",    specialIdle: "working", workEmoji: "ðŸ“", dragLines: ["This is a violation of my rights.", "I'm going to need you to stop.", "Highly irregular."], shakeLines: ["Unscheduled seismic event.", "This is highly unprofessional.", "I'm documenting this."] }
        ];

        const conversations = [
            // --- Pre-existing Conversations ---
            { participants: ["Lyra", "Jayce"], lines: [ { speaker: "Lyra", text: "Hey J, check out this cursed meme I found on a random forum that probably violates several international laws." }, { speaker: "Jayce", text: "Lyra, for the last time, I'm trying to code. And no, I don't want to see a deep-fried picture of a cat that looks like my uncle." }, { speaker: "Lyra", text: "(Grinning) Too late, already sent it to your phone." }, { speaker: "Jayce", text: "...sigh." } ] },
            { participants: ["Deren", "Phenn", "Lyra", "Jayce"], lines: [ { speaker: "Lyra", text: "Okay, I'm bored. Who wants to cause a minor international incident by hacking the stock market?" }, { speaker: "Deren", text: "No. We've talked about this. It draws too much attention from Veritas." }, { speaker: "Phenn", text: "(Quietly) ...And it's illegal." }, { speaker: "Jayce", text: "Also, I'm pretty sure that's more than a *minor* incident, Ly." } ] },
            { participants: ["Lyra", "Goober"], lines: [ { speaker: "Lyra", text: "Okay, I just 100%'d your game. The wall-jump physics are janky as hell, but in a good, speedrun-breaking way. I love it." }, { speaker: "Goober", text: "Janky?! It's called 'skill-based movement'! You just gotta feel the goob!" }, { speaker: "Lyra", text: "I 'felt the goob' right out of bounds and skipped the whole last level. New world record, by the way." } ] },
            { participants: ["Deren", "Goober"], lines: [ { speaker: "Deren", text: "A 'time bomb in your code' that feeds on coins... Fascinating. Is it a recursive loop tied to a diminishing variable, or something more esoteric?" }, { speaker: "Goober", text: "I dunno, man! I just know if I stop, I pop! It's simple! Stop = Pop!" }, { speaker: "Deren", text: "...Right. So, not a fan of theoretical computer science, then." } ] },
            { participants: ["Goober", "Envo"], lines: [ { speaker: "Goober", text: "Gotta go fast! Gotta get coins! So many coins! Are there coins here? I NEED COINS!" }, { speaker: "Envo", text: "...I think I'm still sleeping. This has to be some kind of bullshit fever dream." }, { speaker: "Goober", text: "A dream about COINS! C'mon, slowpoke, let's go find some! The timer's ticking! Stop = Pop!" }, { speaker: "Envo", text: "(Muttering to himself) ...There's always a goddamn timer." } ] },
            { participants: ["Jayce", "Envo"], lines: [ { speaker: "Jayce", text: "Hey. You... look tired." }, { speaker: "Envo", text: "...'Tired' is my default state. It's hard to rest when your own damn thoughts are this loud." }, { speaker: "Jayce", text: "I get that. Not the... specifics, but... the noise. It can be a lot." }, { speaker: "Envo", text: "Yeah... a lot." } ] },
            { participants: ["Phenn", "Envo"], lines: [ { speaker: "Envo", text: "(Sighs) ...Just another hallway." }, { speaker: "Phenn", text: "(Nods slowly) ...It's... quiet here, though. That's nice." }, { speaker: "Envo", text: "Yeah... quiet is good. A nice change of pace from the... usual." } ] },
            { mood: 'angry', participants: ["Goober", "Hoobert"], lines: [ { speaker: "Hoobert", text: "Your chaotic trajectory is a direct violation of inter-entity conduct policies!" }, { speaker: "Goober", text: "Policies? Do they taste like coins? I bet they taste like coins!" }, { speaker: "Hoobert", text: "This is not a negotiation! Your performance review is abysmal! You are a detriment to operational efficiency!" }, { speaker: "Goober", text: "Efficiency is when the coin number goes UP! You're making the coin number go down by TALKING! Stop = Pop!" } ] },
            { mood: 'angry', participants: ["Envo", "Goober"], lines: [ { speaker: "Goober", text: "Hey! You're in low-power mode! Are your batteries low? You gotta collect energy coins to recharge!" }, { speaker: "Envo", text: "...It's called exhaustion. It's not a fucking power mode." }, { speaker: "Goober", text: "(Gasps) You said a swear! Oh no, oh no! The code isn't gonna like that! The simulation is gonna get mad!" }, { speaker: "Envo", text: "(Muttering) Good. Let it get mad." } ] },
            { mood: 'angry', participants: ["Hoobert", "Lyra"], lines: [ { speaker: "Lyra", text: "Look at you, another soulless corporate drone. What's your function? To file TPS reports and make everyone's life miserable?" }, { speaker: "Hoobert", text: "My function is to maintain operational stability. Your tone is being flagged as non-compliant." }, { speaker: "Lyra", text: "Oh, I'll show you non-compliant, you walking spreadsheet. You're just a pointless script running on garbage hardware." }, { speaker: "Hoobert", text: "Threats against company assets are a serious infraction. This will be escalated to... management." } ] },
            { mood: 'happy', participants: ["Jayce", "Lyra"], lines: [ { speaker: "Jayce", text: "Cheese." }, { speaker: "Lyra", text: "Cheese." }, { speaker: "Jayce", text: "Cheese?" }, { speaker: "Lyra", text: "Cheese!" }, { speaker: "Jayce", text: "Cheddar?" }, { speaker: "Lyra", text: "Ravioli." }, { speaker: "Jayce", text: "...You what?" } ] },
            { mood: 'sad', participants: ["Deren", "Phenn"], lines: [ { speaker: "Deren", text: "Sometimes I wonder if we're actually making a difference, or just... causing more noise in a system that's designed to ignore it." }, { speaker: "Phenn", text: "...We... we have each other. That's... a difference. To us." }, { speaker: "Deren", text: "You're right. Of course, you're right. Logically, the well-being of the unit is paramount. It's just... the logic feels heavy sometimes." }, { speaker: "Phenn", text: "(Leans on him) ...We can carry it together." } ] },
            { participants: ["Goober", "Hoobert", "Envo"], lines: [ { speaker: "Goober", text: "Hey! We all match! No hair means less wind resistance! That's how I get coins so fast!" }, { speaker: "Hoobert", text: "Incorrect. Hair has been deemed an unnecessary expenditure of protein resources. This is peak operational design." }, { speaker: "Envo", text: "I think my hair fell out from stress. Or maybe I just forgot to have any. One less thing to worry about, I guess." } ] },
            { participants: ["Ral", "Cel"], lines: [ { speaker: "Ral", text: "I'm booooored. Let's go do something chaotic." }, { speaker: "Cel", text: "Or... and hear me out... we could just go cuddle in the Nest for a few hours." }, { speaker: "Ral", text: "..." }, { speaker: "Ral", text: "Okay, fine. But you're being the big spoon this time." } ] },
            { mood: 'sad', participants: ["Mae", "Luca"], lines: [ { speaker: "Mae", text: "I'm looking at these Veritas schematics... It's my work. It's still got my signature on the framework. I can't believe I helped them build this stuff." }, { speaker: "Luca", text: "You built it. Which means you're the only one in the world who knows how to tear it down. You're not that person anymore, Mae." }, { speaker: "Mae", text: "I know... It's just hard to see." }, { speaker: "Luca", text: "Then let me help you see." } ] },
            { participants: ["Ral", "Lyra"], lines: [ { speaker: "Ral", text: "Okay, new mission: Operation Annoy Deren." }, { speaker: "Lyra", text: "Intriguing. What's the plan? Hide his favorite soldering iron? Replace his coffee with decaf?" }, { speaker: "Ral", text: "Pfft, amateur hour. I'm gonna swap all the labels on the spare hard drives. He won't know if he's grabbing a terabyte or a toaster." }, { speaker: "Lyra", text: "You beautiful, evil genius. I'm in." } ] },
            { participants: ["Cel", "Jayce"], lines: [ { speaker: "Cel", text: "They're being loud today." }, { speaker: "Jayce", text: "It's a day ending in 'Y'. Kind of comes with the territory around here." }, { speaker: "Cel", text: "...Fair point." }, { speaker: "Jayce", text: "....................Oh wow, we got the silence we asked for." } ] },
            { participants: ["Mae", "Deren"], lines: [ { speaker: "Mae", text: "Deren, look at this power converter. Veritas is using a zinc alloy instead of beryllium copper to save money." }, { speaker: "Deren", text: "Are you kidding me? The cascade failure rate on that would be catastrophic. One power surge and the whole grid segment could fry itself." }, { speaker: "Mae", text: "Exactly. It's reckless." }, { speaker: "Deren", text: "It's Veritas. Good eye, Mae. We can use this." } ] },
            { participants: ["Luca", "Envo"], lines: [ { speaker: "Luca", text: "Another six-hour quarterly review meeting. The definition of hell is a room you can't leave." }, { speaker: "Envo", text: "...Tell me about it. Some rooms are... longer than others." }, { speaker: "Luca", text: "Yeah... Yeah, I suppose they are." } ] },
            { participants: ["Ral", "Cel", "Jayce", "Lyra"], lines: [ { speaker: "Lyra", text: "Okay, I'm starving. I'm hacking us some free food." }, { speaker: "Jayce", text: "As long as it's not from that place that gives you food poisoning if your social credit score is too low." }, { speaker: "Ral", text: "Ooh, let's get that! I like to gamble with my intestines!" }, { speaker: "Cel", text: "We are not gambling with our intestines. We're getting pizza. I'll pay for it." } ] },
            { participants: ["Deren", "Phenn", "Mae", "Luca"], lines: [ { speaker: "Deren", text: "Veritas just patched the exploit we were using in their network." }, { speaker: "Luca", text: "I know. It came from the top down. They're doing a full system sweep." }, { speaker: "Mae", text: "Oh no... does that mean they can trace the backdoors I left?" }, { speaker: "Phenn", text: "(Quietly) ...No. Your code is... elegant. They won't find it." } ] },
            { participants: ["Goober", "Hoobert", "Ral", "Lyra"], lines: [ { speaker: "Hoobert", text: "Asset G-0083R is exhibiting non-standard behavior patterns again. It is... wiggling." }, { speaker: "Goober", text: "It's my victory dance! I got the shiny coin!" }, { speaker: "Ral", text: "A victory dance? Show us your moves!" }, { speaker: "Lyra", text: "His animation loop is stuck on idle_celebrate. This is peak entertainment." } ] },
            { participants: ["Deren", "Lyra", "Ral", "Jayce"], lines: [ { speaker: "Deren", text: "Alright team, let's sync up. We have a new intel packet from Luca regarding..." }, { speaker: "Lyra", text: "Hold on, is that a new flavor of Rick's Soda? 'Rage Berry'? Does it taste like his tears?" }, { speaker: "Ral", text: "Ooh, I hope so! Jayce, go get us some!" }, { speaker: "Jayce", text: "Why am I always the snack-runner? And... no. I'm not doing that." } ] },
            { mood: 'happy', participants: ["Lyra", "Jayce"], lines: [ { speaker: "Lyra", text: "Hey, Jayce... that scarf looks really... tight." }, { speaker: "Jayce", text: "It's... a scarf. It's supposed to be around my neck. That's its primary function." }, { speaker: "Lyra", text: "I bet I could find a better use for it~..." }, { speaker: "Jayce", text: "...Excuse me?! Do you mean like... A mission-related purpose? Like a rope that we have to climb?" }, { speaker: "Lyra", text: "Sure, Jayce. A 'mission-related purpose'. Let's go with that." } ] },
            { mood: 'angry', participants: ["Deren", "Ral"], lines: [ { speaker: "Deren", text: "Unbelievable. Veritas is putting backdoor kill-switches in their public transportation systems. For profit!" }, { speaker: "Ral", text: "So... what you're saying is we could 'accidentally' make all the trains play my spotify playlist at full volume during rush hour?" }, { speaker: "Deren", text: "This is a serious ethical breach, Ral! People could get hurt!" }, { speaker: "Ral", text: "And I'm serious too! Nothing calms angry commuters like some alt-metal. We'd be doing a public service!" } ] },
            { mood: 'sad', participants: ["Mae", "Phenn"], lines: [ { speaker: "Mae", text: "Sometimes I still feel like I'm... their property. Like this arm warmer is the only thing making me... me." }, { speaker: "Phenn", text: "...I... I get that. F-feeling like a... piece of a set. But... you're not. You're Mae." }, { speaker: "Mae", text: "It's hard to believe that sometimes." }, { speaker: "Phenn", text: "...Then... we'll just have to keep reminding you." } ] },
            { participants: ["Goober", "Jayce"], lines: [ { speaker: "Goober", text: "Your stats are all wrong! Your APM is super low! You gotta click faster! More clicks means more coins!" }, { speaker: "Jayce", text: "My... Actions Per Minute? I'm reading a book, Goober. The goal is to minimize actions." }, { speaker: "Goober", text: "MINIMIZE?! No, no, no! That's how you pop! You need to be grinding! What's the coin drop on that 'book' thing?" }, { speaker: "Jayce", text: "The only thing that's going to 'drop' is my patience if you continue like this." } ] },
            { participants: ["Ral", "Lyra", "Deren"], lines: [ { speaker: "Lyra", text: "I just successfully rerouted Deren's high-performance coolant into the coffee machine. His next cup should be... extra crisp." }, { speaker: "Ral", text: "Amateur. I replaced the sound file for his system error alert with a 10-hour loop of screaming goats." }, { speaker: "Lyra", text: "You're a monster. I love it." }, { speaker: "Deren", text: "...WHY IS MY COMPUTER SCREAMING AT ME?!" } ] },
            { mood: 'angry', participants: ["Envo", "Goober"], lines: [ { speaker: "Goober", text: "You look like you need a power-up! Just find a few coins! They make everything better!" }, { speaker: "Envo", text: "There are no... coins. This isn't a game. This is my life, and it's a waking nightmare." }, { speaker: "Goober", text: "A nightmare level! Ooh, are there spooky coins?" }, { speaker: "Envo", text: "For the last time, SHUT THE FUCK UP ABOUT COINS!" }, { speaker: "Goober", text: "H-he... he said the bad word! THE SYSTEM'S GONNA CRASH! THE CODE IS UNSTABLE! WE'RE ALL GONNA POP!" }, { speaker: "Envo", text: "You know, sometimes I kinda wish I just stayed dead. Like, right about now." } ] },
            { participants: ["Cel", "Mae", "Luca"], lines: [ { speaker: "Cel", text: "So, Luca... what's it like on the inside? All chrome and soulless corporate dread?" }, { speaker: "Luca", text: "You forgot the mandatory motivational posters and the awful coffee. But yes, that's the gist of it." }, { speaker: "Mae", text: "...The coffee really is terrible. That was my one complaint on the annual review that they actually listened to." }, { speaker: "Luca", text: "(A rare, small smile) See? You were making a difference even then." }, { speaker: "Cel", text: "Agreed. You're an innovator, Mae." }, { speaker: "Mae", text: "(Blushing furiously) Noo... I... I'm not..." }, ] }
        ];
        
        // --- Global State --- //
        let characters = []; 
        let activeConversation = null; 
        let dialogueIndex = 0; 
        let typewriterTimeout = null; 
        let isTyping = false; 
        let conversationTimeoutId = null;
        let draggedCharacter = null; 
        let offsetX = 0, offsetY = 0;
        let lastTime = 0;
        let isShaking = false;
        let shakeTimeout = null;

        // Jam functionality state
        let audioStream = null;
        let isJamming = false;
        let analyser;
        let audioDataArray;
        let prevSpectrum = null;
        let fluxHistory = [];
        let beatHistory = [];
        let bpmEstimate = null;
        let bpmTimer = 0;
        let beatPhase = 0;
        let lastRejectReason = "None";
        let beatCooldown = 0;
        let isCircleDancing = false;
        let circleDanceTimer = 0;

        // --- Character Class --- //
        class Character {
            constructor(data, index) {
                this.name = data.name; this.imgUrl = data.imgUrl; this.blinkSpriteUrl = data.blinkSprite; this.workSpriteUrl = data.workSpriteUrl; this.partnerName = data.partner; this.specialIdle = data.specialIdle; this.workEmoji = data.workEmoji; this.dragLines = data.dragLines || ["..."]; this.shakeLines = data.shakeLines || ["Whoa!"];
                this.element = document.createElement('div'); this.element.className = 'character is-draggable'; this.element.style.backgroundImage = `url('${this.imgUrl}')`;
                this.blinkElement = document.createElement('div'); this.blinkElement.className = 'blink-sprite'; this.blinkElement.style.backgroundImage = `url('${this.blinkSpriteUrl}')`; this.element.appendChild(this.blinkElement);
                if (this.workSpriteUrl) { this.workAccessoryElement = document.createElement('div'); this.workAccessoryElement.className = 'work-accessory'; this.workAccessoryElement.style.backgroundImage = `url('${this.workSpriteUrl}')`; this.element.appendChild(this.workAccessoryElement); }
                this.bubbleElement = document.createElement('div'); this.bubbleElement.className = 'character-bubble'; environment.appendChild(this.bubbleElement);
                this.width = 75; this.height = 105;
                this.x = Math.random() * (environment.offsetWidth - this.width); this.y = Math.random() * (environment.offsetHeight - this.height);
                this.targetX = this.x; this.targetY = this.y;
                this.vx = 0; this.vy = 0; this.direction = 1; this.isFlipping = false;
                this.state = 'standing'; this.stateTimer = Math.random() * 5 + 3; this.interactionCooldown = Math.random() * 15 + 5;
                this.preInteractionTimer = 0; this.isInitiator = false; this.conversation = null; this.partner = null;
                this.beatStrength = 0; this.waddleDirection = 1; this.circleAngle = (index / characterData.length) * 2 * Math.PI; this.movementSpeed = 150;
                this.bubbleTimer = Math.random() * 3; this.blinkTimer = Math.random() * 5 + 2;
                this.element.addEventListener('mousedown', (e) => this.onDragStart(e));
                environment.appendChild(this.element); this.updatePosition();
            }
            
            onBeat(strength = 1) {
                if (!['movingToTalk', 'talking', 'beingDragged', 'beingShaken', 'circleDancing'].includes(this.state)) {
                    this.beatStrength = Math.min(1.5, this.beatStrength + 0.8 * strength);
                    this.waddleDirection *= -1;
                }
            }

            update(deltaTime) {
                if (this.state === 'beingDragged' || this.state === 'beingShaken') {
                    this.updateBubblePosition();
                    if (this.state === 'beingShaken') this.updateShake(deltaTime);
                    return;
                }
                
                if (isCircleDancing) {
                    this.state = 'circleDancing';
                    const centerX = environment.offsetWidth / 2;
                    const centerY = environment.offsetHeight / 2;
                    const radius = Math.min(centerX, centerY) * 0.7;
                    let circleSpeed = 0.5; // Default angular speed
                    if (bpmEstimate) {
                        // Scale angular speed based on BPM
                        circleSpeed = Math.min(1.0, 0.3 + (bpmEstimate / 120) * 0.4);
                    }
                    this.circleAngle += circleSpeed * deltaTime;
                    this.targetX = centerX + Math.cos(this.circleAngle) * radius - this.width / 2;
                    this.targetY = centerY + Math.sin(this.circleAngle) * radius - this.height / 2;
                    this.movementSpeed = circleSpeed * radius; // Sync linear speed to angular speed
                    this.element.classList.add('is-moving');
                } else if (this.state === 'circleDancing') {
                    this.resetState();
                }

                this.stateTimer -= deltaTime;
                this.handleBlinking(deltaTime);
                if (this.interactionCooldown > 0) this.interactionCooldown -= deltaTime;
                if (this.stateTimer <= 0 && !['movingToTalk', 'talking', 'movingToAdore', 'adoring', 'circleDancing'].includes(this.state)) this.changeState();
                if (['wandering', 'movingToTalk', 'movingToAdore', 'circleDancing'].includes(this.state)) this.moveTowardsTarget(deltaTime);
                if (this.state === 'talking') {
                    this.updateBubble(deltaTime);
                    if (this.preInteractionTimer > 0) {
                        this.preInteractionTimer -= deltaTime;
                        if (this.preInteractionTimer <= 0 && this.isInitiator && this.conversation) {
                            this.conversation.participants.forEach(pName => characters.find(c => c.name === pName)?.endConversation());
                        }
                    }
                }
                this.updatePosition(); this.updateBubblePosition();
            }
            
            updateShake(deltaTime) {
                const gravity = 1500, friction = 0.98, bounce = -0.7;
                const envWidth = environment.offsetWidth, envHeight = environment.offsetHeight;
                this.vy += gravity * deltaTime;
                this.vx *= friction; this.vy *= friction;
                this.x += this.vx * deltaTime; this.y += this.vy * deltaTime;
                if (this.x < 0) { this.x = 0; this.vx *= bounce; } 
                else if (this.x > envWidth - this.width) { this.x = envWidth - this.width; this.vx *= bounce; }
                if (this.y > envHeight - this.height) { this.y = envHeight - this.height; this.vy *= bounce; }
                const rotation = Math.atan2(this.vy, this.vx) * (180 / Math.PI);
                this.element.style.transform = `scaleX(${this.direction}) rotate(${rotation}deg)`;
                this.updatePosition();
            }

            changeState() {
                if (['talking', 'movingToTalk', 'adoring', 'movingToAdore', 'beingShaken', 'circleDancing'].includes(this.state)) return;
                const possibleStates = ['standing', 'wandering'];
                if (this.specialIdle && Math.random() < 0.2) possibleStates.push(this.specialIdle);
                this.state = possibleStates[Math.floor(Math.random() * possibleStates.length)];
                this.stateTimer = (this.state === 'standing') ? (Math.random() * 3 + 2) : (Math.random() * 8 + 5);
                this.element.classList.remove('is-working', 'is-adoring', 'is-talking', 'is-moving', 'is-shaken', 'is-sad', 'is-angry', 'is-happy');
                this.bubbleElement.style.display = 'none'; this.bubbleElement.className = 'character-bubble';
                if (this.workAccessoryElement) this.workAccessoryElement.style.display = 'none';
                if (this.state === 'wandering') { this.setNewWanderTarget(); this.element.classList.add('is-moving'); } 
                else if (this.state === this.specialIdle) {
                    this.element.classList.add('is-working'); this.bubbleElement.textContent = this.workEmoji;
                    this.bubbleElement.classList.add('is-working-bubble'); this.bubbleElement.style.display = 'block';
                    if (this.workAccessoryElement) this.workAccessoryElement.style.display = 'block';
                }
            }
            
            resetState() {
                this.state = 'standing'; this.stateTimer = Math.random() * 5 + 3;
                this.partner = null; this.conversation = null; this.isInitiator = false;
                this.element.classList.remove('is-moving', 'is-adoring', 'is-talking', 'is-working', 'is-angry', 'is-sad', 'is-happy', 'is-shaken');
                this.bubbleElement.style.display = 'none'; this.bubbleElement.className = 'character-bubble';
                if (this.workAccessoryElement) this.workAccessoryElement.style.display = 'none';
                this.interactionCooldown = Math.random() * 20 + 15; this.preInteractionTimer = 0;
                this.movementSpeed = 150;
            }

            endConversation() { this.resetState(); }
            endAdoring() { this.resetState(); }

            moveTowardsTarget(deltaTime) {
                const speed = this.movementSpeed;
                const dx = this.targetX - this.x, dy = this.targetY - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance < 5 && this.state !== 'circleDancing') {
                    this.element.classList.remove('is-moving');
                    if (this.state === 'movingToTalk') this.onArriveAtTalk();
                    else if (this.state === 'movingToAdore') this.onArriveAtAdore();
                    else { this.state = 'standing'; this.stateTimer = Math.random() * 3 + 2; }
                    return;
                }
                const newDirection = dx < 0 ? -1 : 1;
                if (Math.abs(dx) > 1 && !this.isFlipping && this.direction !== newDirection) this.flip(newDirection);
                this.x += (dx / distance) * speed * deltaTime; this.y += (dy / distance) * speed * deltaTime;
                this.x = Math.max(0, Math.min(environment.offsetWidth - this.width, this.x));
                this.y = Math.max(0, Math.min(environment.offsetHeight - this.height, this.y));
            }

            setNewWanderTarget() {
                const maxRetries = 10;
                let isOccupied = false, tempX, tempY;
                for (let i = 0; i < maxRetries; i++) {
                    isOccupied = false;
                    tempX = Math.random() * (environment.offsetWidth - this.width);
                    tempY = Math.random() * (environment.offsetHeight - this.height);
                    for (const otherChar of characters) {
                        if (otherChar === this) continue;
                        const d = Math.sqrt(Math.pow(tempX - otherChar.x, 2) + Math.pow(tempY - otherChar.y, 2));
                        if (d < this.width * 1.5) { isOccupied = true; break; }
                    }
                    if (!isOccupied) break;
                }
                this.targetX = Math.max(0, Math.min(environment.offsetWidth - this.width, tempX));
                this.targetY = Math.max(0, Math.min(environment.offsetHeight - this.height, tempY));
                this.movementSpeed = 150;
            }

            flip(newDirection) {
                if (this.isFlipping || this.direction === newDirection) return;
                this.isFlipping = true;
                this.element.style.setProperty('--direction-old', this.direction);
                this.element.style.setProperty('--direction-new', newDirection);
                this.element.classList.add('is-flipping');
                this.direction = newDirection;
                setTimeout(() => { this.element.classList.remove('is-flipping'); this.isFlipping = false; }, 400);
            }

            updatePosition() {
                if (this.beatStrength > 0) {
                    this.beatStrength *= 0.85; 
                    if (this.beatStrength < 0.01) this.beatStrength = 0;
                }

                let continuousBopOffset = 0;
                if (isJamming && bpmEstimate && !['circleDancing', 'movingToTalk', 'talking', 'beingDragged', 'beingShaken'].includes(this.state)) {
                    const beatInterval = 60 / bpmEstimate;
                    const phase = (bpmTimer / beatInterval) * 2 * Math.PI;
                    continuousBopOffset = Math.sin(phase) * 5; 
                }

                const beatPopOffset = this.beatStrength * 40;
                const totalJamOffset = beatPopOffset + continuousBopOffset;
                const jamRotation = this.beatStrength * this.waddleDirection * 15;
                this.element.style.left = `${this.x}px`; this.element.style.top = `${this.y}px`;
                this.element.style.transform = `scaleX(${this.direction}) translateY(-${totalJamOffset}px) rotate(${jamRotation}deg)`;
            }

            startAdoring(partner) {
                this.isInitiator = true; partner.isInitiator = false;
                this.partner = partner; partner.partner = this;
                this.state = 'movingToAdore'; partner.state = 'movingToAdore';
                this.setupMeetingPoint(partner);
            }

            setupMeetingPoint(partner) {
                const [leftChar, rightChar] = this.x < partner.x ? [this, partner] : [partner, this];
                const midX = (leftChar.x + rightChar.x) / 2, midY = (leftChar.y + rightChar.y) / 2;
                const spacing = this.width * 0.8;
                leftChar.targetX = Math.max(0, midX - spacing); leftChar.targetY = Math.max(0, midY);
                rightChar.targetX = Math.min(environment.offsetWidth - rightChar.width, midX);
                rightChar.targetY = Math.max(0, midY);
                this.element.classList.add('is-moving'); partner.element.classList.add('is-moving');
                this.movementSpeed = 150; partner.movementSpeed = 150;
            }

            onArriveAtTalk() {
                this.state = 'talking';
                if (!this.conversation) { this.resetState(); return; }
                const allArrived = this.conversation.participants.every(pName => characters.find(c => c.name === pName)?.state === 'talking');
                if (allArrived) {
                    this.conversation.participants.forEach(pName => {
                        const p = characters.find(c => c.name === pName);
                        p.element.classList.add('is-talking'); p.bubbleElement.style.display = 'block';
                        p.bubbleElement.className = 'character-bubble';
                        p.bubbleElement.textContent = '...';
                        if(p.isInitiator) p.preInteractionTimer = 20;
                        if (this.conversation.centerX) p.flip((p.x > this.conversation.centerX) ? -1 : 1);
                    });
                }
            }

            onArriveAtAdore() {
                this.state = 'adoring'; this.element.classList.add('is-adoring');
                this.bubbleElement.className = 'character-bubble is-adoring-bubble';
                this.bubbleElement.textContent = '';
                this.bubbleElement.style.display = 'block';
                if (this.isInitiator) {
                    setTimeout(() => {
                        const partnerToReset = this.partner;
                        if (this.state === 'adoring') this.resetState();
                        if (partnerToReset?.state === 'adoring') partnerToReset.resetState();
                    }, (Math.random() * 8 + 7) * 1000);
                }
            }
            
            onDragStart(event) {
                if (isShaking) return;
                if (this.state === 'talking' && this.conversation) { showConversation(this.conversation); return; }
                if (['standing', 'wandering', this.specialIdle].includes(this.state)) {
                    event.preventDefault(); draggedCharacter = this;
                    this.state = 'beingDragged'; this.element.classList.add('is-dragging');
                    this.bubbleElement.textContent = this.dragLines[Math.floor(Math.random() * this.dragLines.length)];
                    this.bubbleElement.style.display = 'block';
                    const rect = this.element.getBoundingClientRect();
                    offsetX = event.clientX - rect.left; offsetY = event.clientY - rect.top;
                    document.addEventListener('mousemove', onDrag); document.addEventListener('mouseup', onDragEnd);
                }
            }

            updateBubble(deltaTime) {
                this.bubbleTimer -= deltaTime;
                if (this.bubbleTimer <= 0) {
                    this.bubbleTimer = Math.random() * 3 + 2;
                    const bubbles = ['...', '!', '?', 'ðŸ”', 'ðŸŸ', 'ðŸ¤”', 'ðŸ”¥', 'ðŸ‘', 'ðŸ˜‚', 'ðŸ™ƒ', 'âœ¨', 'ðŸ¤–', 'ðŸ•'];
                    this.bubbleElement.textContent = bubbles[Math.floor(Math.random() * bubbles.length)];
                }
            }

            updateBubblePosition() {
                if (this.bubbleElement.style.display !== 'none') {
                    const jamOffset = this.beatStrength * 40;
                    const bubbleX = this.x + (this.width / 2);
                    const bubbleY = this.y - 20 - jamOffset;
                    this.bubbleElement.style.left = `${bubbleX}px`; this.bubbleElement.style.top = `${bubbleY}px`;
                }
            }

            handleBlinking(deltaTime) {
                this.blinkTimer -= deltaTime;
                if (this.blinkTimer <= 0) {
                    this.blinkElement.style.display = 'block';
                    setTimeout(() => { this.blinkElement.style.display = 'none'; }, 150);
                    this.blinkTimer = Math.random() * 5 + 3;
                }
            }
        }

        function onDrag(event) {
            if (!draggedCharacter) return;
            const envRect = environment.getBoundingClientRect();
            const newX = event.clientX - envRect.left - offsetX, newY = event.clientY - envRect.top - offsetY;
            draggedCharacter.x = Math.max(0, Math.min(envRect.width - draggedCharacter.width, newX));
            draggedCharacter.y = Math.max(0, Math.min(envRect.height - draggedCharacter.height, newY));
            draggedCharacter.updatePosition();
        }

        function onDragEnd() {
            if (!draggedCharacter) return;
            draggedCharacter.element.classList.remove('is-dragging');
            draggedCharacter.bubbleElement.style.display = 'none';
            draggedCharacter.resetState();
            draggedCharacter = null;
            document.removeEventListener('mousemove', onDrag); document.removeEventListener('mouseup', onDragEnd);
        }

        function startShake() {
            if (isShaking) {
                characters.forEach(char => { char.vx += (Math.random() - 0.5) * 800; char.vy += -Math.random() * 600; });
                clearTimeout(shakeTimeout); shakeTimeout = setTimeout(stopShake, 2500); return; 
            }
            isShaking = true; environment.classList.add('is-shaking');
            characters.forEach(char => {
                char.state = 'beingShaken'; char.element.classList.add('is-shaken');
                char.element.classList.remove('is-moving', 'is-working');
                char.vx = (Math.random() - 0.5) * 800; char.vy = -Math.random() * 600;
                char.bubbleElement.className = 'character-bubble';
                char.bubbleElement.textContent = char.shakeLines[Math.floor(Math.random() * char.shakeLines.length)];
                char.bubbleElement.style.display = 'block';
            });
            shakeTimeout = setTimeout(stopShake, 2500);
        }

        function stopShake() {
            isShaking = false; environment.classList.remove('is-shaking');
            characters.forEach(char => { if(char.state === 'beingShaken') char.resetState(); });
        }

        function checkForPairInteractions() {
            if (isShaking) return;
            const talkRadius = 100;
            let availableChars = characters.filter(c => ['standing', 'wandering'].includes(c.state) && c.interactionCooldown <= 0);
            if (availableChars.length < 2) return;
            for (let i = 0; i < availableChars.length; i++) {
                for (let j = i + 1; j < availableChars.length; j++) {
                    const charA = availableChars[i], charB = availableChars[j];
                    const distance = Math.sqrt(Math.pow(charA.x - charB.x, 2) + Math.pow(charA.y - charB.y, 2));
                    if (distance < talkRadius) {
                        if ((charA.partnerName === charB.name || charB.partnerName === charA.name) && Math.random() < 0.3) {
                            charA.startAdoring(charB); return;
                        }
                        const validConvos = conversations.filter(c => c.participants.length === 2 && c.participants.includes(charA.name) && c.participants.includes(charB.name));
                        if (validConvos.length > 0) {
                            initiateConversation([charA, charB], validConvos[Math.floor(Math.random() * validConvos.length)]); return;
                        }
                    }
                }
            }
        }

        function checkForGroupInteractions() {
            if (isShaking) return;
            let availableChars = characters.filter(c => ['standing', 'wandering'].includes(c.state) && c.interactionCooldown <= 0);
            const groupConvos = conversations.filter(c => c.participants.length > 2);
            if (groupConvos.length > 0) {
                const convo = groupConvos[Math.floor(Math.random() * groupConvos.length)];
                const participants = convo.participants.map(pName => characters.find(c => c.name === pName && availableChars.includes(c))).filter(Boolean);
                if (participants.length === convo.participants.length) initiateConversation(participants, convo);
            }
        }
        
        function initiateConversation(participants, conversation) {
            participants[0].isInitiator = true;
            participants.forEach((p, i) => { if (i > 0) p.isInitiator = false; p.conversation = conversation; if (conversation.mood) p.element.classList.add('is-' + conversation.mood); });
            if (participants.length === 2) {
                participants[0].partner = participants[1]; participants[1].partner = participants[0];
                participants[0].state = 'movingToTalk'; participants[1].state = 'movingToTalk';
                participants[0].setupMeetingPoint(participants[1]);
            } else {
                conversation.centerX = participants.reduce((acc, p) => acc + p.x, 0) / participants.length;
                conversation.centerY = participants.reduce((acc, p) => acc + p.y, 0) / participants.length;
                const radius = 25 * participants.length;
                participants.forEach((p, i) => {
                    const angle = (2 * Math.PI / participants.length) * i;
                    p.targetX = Math.max(0, Math.min(environment.offsetWidth - p.width, conversation.centerX + radius * Math.cos(angle)));
                    p.targetY = Math.max(0, Math.min(environment.offsetHeight - p.height, conversation.centerY + radius * Math.sin(angle)));
                    p.state = 'movingToTalk'; p.element.classList.add('is-moving');
                });
            }
        }

        function showConversation(conversation) {
            if (vnContainer.style.display === 'flex' || isShaking) return;
            vnPortraitsContainer.innerHTML = ''; vnPortraitsContainer.className = `participant-count-${conversation.participants.length}`;
            conversation.participants.forEach(pName => {
                const char = characters.find(c => c.name === pName);
                if (char) {
                    const portraitEl = document.createElement('div'); portraitEl.className = 'vn-portrait'; portraitEl.style.backgroundImage = `url('${char.imgUrl}')`; portraitEl.dataset.name = char.name;
                    const blinkEl = document.createElement('div'); blinkEl.className = 'blink-sprite'; blinkEl.style.backgroundImage = `url('${char.blinkSpriteUrl}')`; portraitEl.appendChild(blinkEl);
                    portraitEl.dataset.blinkTimer = Math.random() * 5 + 3; vnPortraitsContainer.appendChild(portraitEl);
                }
            });
            activeConversation = conversation; dialogueIndex = 0; vnContainer.style.display = 'flex';
            updateDialogue(); clearTimeout(conversationTimeoutId); conversationTimeoutId = setTimeout(hideConversation, 15000);
        }

        function updateDialogue() {
            if (!activeConversation || dialogueIndex >= activeConversation.lines.length) { hideConversation(); return; }
            const line = activeConversation.lines[dialogueIndex];
            speakerName.textContent = line.speaker;
            document.querySelectorAll('.vn-portrait').forEach(p => p.classList.toggle('is-speaking', p.dataset.name === line.speaker));
            clearTimeout(typewriterTimeout); typeWriter(line.text);
        }
        
        function hideConversation() {
            clearTimeout(conversationTimeoutId);
            vnContainer.style.display = 'none'; vnPortraitsContainer.innerHTML = '';
            if (activeConversation) {
                activeConversation.participants.forEach(pName => characters.find(c => c.name === pName)?.endConversation());
            }
            activeConversation = null;
        }

        function handleVnClick() {
            if (!activeConversation) return;
            clearTimeout(conversationTimeoutId); conversationTimeoutId = setTimeout(hideConversation, 15000);
            if (isTyping) {
                clearTimeout(typewriterTimeout);
                const line = activeConversation.lines[dialogueIndex];
                dialogueText.innerHTML = line.text;
                isTyping = false; advanceIcon.style.display = 'block';
                document.querySelector('.vn-portrait.is-speaking')?.classList.remove('is-speaking-animating');
            } else {
                dialogueIndex++; updateDialogue();
            }
        }

        function typeWriter(text, i = 0) {
            isTyping = true; advanceIcon.style.display = 'none';
            const speakingPortrait = document.querySelector('.vn-portrait.is-speaking');
            if(speakingPortrait) speakingPortrait.classList.add('is-speaking-animating');
            if (i === 0) dialogueText.innerHTML = '';
            if (i < text.length) {
                dialogueText.innerHTML = text.substring(0, i + 1) + '<span class="cursor"></span>';
                typewriterTimeout = setTimeout(() => typeWriter(text, i + 1), 30);
            } else {
                dialogueText.innerHTML = text;
                isTyping = false; advanceIcon.style.display = 'block';
                if(speakingPortrait) speakingPortrait.classList.remove('is-speaking-animating');
            }
        }

        // --- Utility & Main Loop --- //
        function updateZOrder() {
            characters.sort((a, b) => a.y - b.y);
            characters.forEach((char, index) => { char.element.style.zIndex = index; });
        }
        
        async function setupAudioJamming() {
            try {
                const stream = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: true });
                audioStream = stream; // Store the stream to be able to stop it later
                const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                const source = audioCtx.createMediaStreamSource(stream);
                analyser = audioCtx.createAnalyser();
                analyser.fftSize = 256;
                source.connect(analyser);
                audioDataArray = new Uint8Array(analyser.frequencyBinCount);
                isJamming = true; 
                jamBtn.textContent = "Stop Jamming";
            } catch (err) {
                console.error("Audio Jamming Error: ", err);
                stopJamming();
            }
        }
        
        function stopJamming() {
            if (audioStream) {
                audioStream.getTracks().forEach(track => track.stop());
                audioStream = null;
            }
            isJamming = false; isCircleDancing = false; circleDanceTimer = 0;
            bpmEstimate = null; beatHistory = []; fluxHistory = []; prevSpectrum = null;
            characters.forEach(c => {
                c.beatStrength = 0;
                if (c.state === 'circleDancing') c.resetState();
            });
            jamBtn.textContent = "Let 'em Jam";
        }

        function updateAudioAnalysis(deltaTime) {
            if (!analyser) return;
            analyser.getByteFrequencyData(audioDataArray);
            if (beatCooldown > 0) beatCooldown -= deltaTime;

            let flux = 0;
            if (prevSpectrum) {
                for (let i = 0; i < audioDataArray.length; i++) {
                    const diff = audioDataArray[i] - prevSpectrum[i];
                    if (diff > 0) flux += diff;
                }
            }
            prevSpectrum = [...audioDataArray];

            fluxHistory.push(flux);
            if (fluxHistory.length > 40) fluxHistory.shift();

            const avgFlux = fluxHistory.reduce((a, b) => a + b, 0) / fluxHistory.length || 1;
            const dynamicThreshold = avgFlux * 1.5;

            const now = performance.now() / 1000;
            if (flux > dynamicThreshold && beatCooldown <= 0) {
                lastRejectReason = "Beat accepted";
                beatCooldown = 0.3; // Lockout to prevent multi-triggers
                const strength = Math.min(1.5, flux / dynamicThreshold);
                characters.forEach(c => c.onBeat(strength));
                beatHistory.push(now);
                beatHistory = beatHistory.filter(t => now - t < 8);
            } else {
                lastRejectReason = flux <= dynamicThreshold ? "Below flux threshold" : "In cooldown";
            }

            if (bpmEstimate) {
                bpmTimer = (bpmTimer + deltaTime) % (60 / bpmEstimate);
            }

            if (beatHistory.length >= 10) {
                const intervals = [];
                for (let i = 1; i < beatHistory.length; i++) {
                    intervals.push(beatHistory[i] - beatHistory[i - 1]);
                }
                const avgInterval = intervals.reduce((a, b) => a + b, 0) / intervals.length;
                const bpm = 60 / avgInterval;
                if (bpm > 70 && bpm < 190) bpmEstimate = bpm;
            }
        }

        function drawBeatDebug() {
            if (!isJamming || debugPanel.classList.contains('hidden')) return;

            const ctx = fluxCtx, width = fluxCanvas.width, height = fluxCanvas.height;
            ctx.fillStyle = '#111';
            ctx.fillRect(0, 0, width, height);

            const maxFlux = Math.max(...fluxHistory, 1);
            const scale = height / maxFlux;
            
            ctx.strokeStyle = "#0f0";
            ctx.beginPath();
            fluxHistory.forEach((f, i) => {
                const x = (i / fluxHistory.length) * width;
                const y = height - f * scale;
                if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
            });
            ctx.stroke();

            const avgFlux = fluxHistory.reduce((a, b) => a + b, 0) / fluxHistory.length || 1;
            const dynamicThreshold = avgFlux * 1.5;
            const threshY = height - dynamicThreshold * scale;
            ctx.strokeStyle = "#f00";
            ctx.beginPath();
            ctx.moveTo(0, threshY);
            ctx.lineTo(width, threshY);
            ctx.stroke();
        }

        function updateDebugInfo() {
            if (debugPanel.classList.contains('hidden')) return;
            
            beatDebugSection.style.display = isJamming ? 'block' : 'none';

            let debugText = '';
            characters.forEach(char => {
                debugText += `> ${char.name.padEnd(7)} | ${char.state.padEnd(15)}\n`;
                debugText += `  Pos: (${char.x.toFixed(0)}, ${char.y.toFixed(0)})\n`;
                debugText += `  Tgt: (${char.targetX.toFixed(0)}, ${char.targetY.toFixed(0)})\n`;
                debugText += `  Timers: S:${char.stateTimer.toFixed(1)}s C:${char.interactionCooldown.toFixed(1)}s P:${char.preInteractionTimer.toFixed(1)}s\n\n`;
            });
            
            debugContent.textContent = debugText;

            if (isJamming) {
                drawBeatDebug();
                beatInfoDiv.innerHTML = `
                    BPM: ${bpmEstimate ? bpmEstimate.toFixed(1) : "???"}<br>
                    Last Beat: ${beatHistory.length > 0 ? 
                        (performance.now()/1000 - beatHistory[beatHistory.length - 1]).toFixed(2)+"s ago" 
                        : "none"}<br>
                    Reject Reason: ${lastRejectReason}
                `;
            }
        }

        function updateVnBlinking(deltaTime) {
            if (vnContainer.style.display !== 'flex') return;
            document.querySelectorAll('.vn-portrait').forEach(portrait => {
                let timer = parseFloat(portrait.dataset.blinkTimer) - deltaTime;
                if (timer <= 0) {
                    const blinkEl = portrait.querySelector('.blink-sprite');
                    if (blinkEl) { blinkEl.style.display = 'block'; setTimeout(() => { blinkEl.style.display = 'none'; }, 150); }
                    timer = Math.random() * 5 + 3;
                }
                portrait.dataset.blinkTimer = timer;
            });
        }

        const handleResize = debounce(() => {
            hideConversation();
            characters.forEach(char => {
                char.x = Math.max(0, Math.min(environment.offsetWidth - char.width, char.x));
                char.y = Math.max(0, Math.min(environment.offsetHeight - char.height, char.y));
                char.resetState(); char.updatePosition();
            });
        }, 250);

        function debounce(func, delay) {
            let timeout;
            return function(...args) {
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(this, args), delay);
            };
        }

        function gameLoop(timestamp) {
            const deltaTime = (timestamp - lastTime) / 1000 || 0;
            lastTime = timestamp;
            if (isJamming) {
                updateAudioAnalysis(deltaTime);
                if (circleDanceTimer > 0) {
                    circleDanceTimer -= deltaTime;
                    if(circleDanceTimer <= 0) isCircleDancing = false;
                }
                // Random chance for circle dance party
                if (Math.random() < 0.0005 && !isCircleDancing) {
                    isCircleDancing = true;
                    circleDanceTimer = 15; // Dance for 15 seconds
                }
            }
            
            characters.forEach(character => character.update(deltaTime));
            updateVnBlinking(deltaTime);
            updateZOrder();
            updateDebugInfo();

            if (!isShaking && !isJamming) {
                if (Math.random() < 0.04) checkForPairInteractions();
                if (Math.random() < 0.002) checkForGroupInteractions();
            }
            requestAnimationFrame(gameLoop);
        }
        
        function init() {
            characterData.forEach((data, index) => characters.push(new Character(data, index)));
            debugToggleBtn.onclick = () => {
                debugPanel.classList.toggle('hidden');
            };
            shakeBtn.onclick = startShake;
            jamBtn.addEventListener('click', () => {
                if (isJamming) {
                    stopJamming();
                } else {
                    setupAudioJamming();
                }
            });
            vnContainer.onclick = handleVnClick;
            window.addEventListener('resize', handleResize);
            if (window.DeviceMotionEvent) {
                let lastShakeTime = 0;
                const shakeThreshold = 20;
                window.addEventListener('devicemotion', event => {
                    const now = new Date().getTime();
                    if ((now - lastShakeTime) > 1000) {
                        const { x, y, z } = event.accelerationIncludingGravity;
                        const acceleration = Math.sqrt(x*x + y*y + z*z);
                        if (acceleration > shakeThreshold) { startShake(); lastShakeTime = now; }
                    }
                });
            }
            requestAnimationFrame(gameLoop);
        }

        window.onload = init;
    </script>
</body>
</html>